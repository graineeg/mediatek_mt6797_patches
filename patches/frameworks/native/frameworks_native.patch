From 9645f6f203a0bf6eaef5340ace435fe4a8cf7d14 Mon Sep 17 00:00:00 2001
From: DarkKnight6499 <yazad.madan@gmail.com>
Date: Mon, 19 Dec 2016 03:23:02 +0000
Subject: [PATCH] libui:Add MTK Bits

---
 include/ui/Fence.h                                 |   5 +
 include/ui/GraphicBufferMapper.h                   |   9 ++
 include/ui/mediatek/IDumpTunnel.h                  |  50 +++++++++
 include/ui/mediatek/RefBaseDump.h                  |  64 ++++++++++++
 libs/ui/Android.mk                                 |  15 +++
 libs/ui/GraphicBufferMapper.cpp                    |  22 ++++
 libs/ui/mediatek/Fence.cpp                         |  60 +++++++++++
 libs/ui/mediatek/IDumpTunnel.cpp                   | 115 +++++++++++++++++++++
 libs/ui/mediatek/RefBaseDump.cpp                   | 112 ++++++++++++++++++++
 libs/ui/mediatek/test/Android.mk                   |   1 +
 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk |  16 +++
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp   | 106 +++++++++++++++++++
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.h     |  18 ++++
 13 files changed, 593 insertions(+)
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp
 create mode 100644 libs/ui/mediatek/test/Android.mk
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h

diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index b431bd5..befd640 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -110,6 +110,11 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+
+#ifdef MTK_HARDWARE
+private:
+    void dump(int fd);
+#endif
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index a25809c..37b819c 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -66,6 +66,15 @@ private:
     std::unique_ptr<Gralloc1::Device> mDevice;
 };
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
+
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 0000000..4ab32da
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,50 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
+
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 0000000..a6a483d
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,64 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <utils/KeyedVector.h>
+#include <utils/Singleton.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android
+{
+class RefBaseMonitor;
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+class RefBaseDump : public BnDumpTunnel {
+
+public:
+    RefBaseDump(RefBaseMonitor*);
+    virtual ~RefBaseDump();
+
+    // IDumpTunnel interface
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
+
+private:
+    RefBaseMonitor *mMonitor;
+};
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public Singleton<RefBaseMonitor> {
+public:
+    RefBaseMonitor();
+    virtual ~RefBaseMonitor();
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* );
+
+    // remove refbase from the monitored list
+    status_t unmonitor(RefBase* );
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result);
+
+private:
+    status_t getProcessName();
+
+    // if trackMe needed
+    bool mIsTracking;
+
+    String8 mProcessName;
+
+    sp<RefBaseDump> mDump;
+
+    // the list where monitored refbase objects are saved
+    KeyedVector<RefBase*,int> RbList;
+
+    mutable Mutex mMutex;;
+};
+
+};
+#endif
+
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index e690ede..97bfc14 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -48,6 +48,16 @@ LOCAL_SRC_FILES := \
 	Region.cpp \
 	UiConfig.cpp
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+	mediatek/Fence.cpp \
+	mediatek/IDumpTunnel.cpp \
+	mediatek/RefBaseDump.cpp
+
+# just make everything compile for now... cleanups later
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
 	libcutils \
@@ -56,6 +66,11 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	liblog
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SHARED_LIBRARIES += \
+	libbinder
+endif
+
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 481d43c..d30d1ec 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -91,6 +91,28 @@ static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
     return outRect;
 }
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
+extern status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(buffer_handle_t, uint32_t, const Rect&, android_ycbcr *);
+
+
+status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
+        int usage, const Rect& bounds, void** vaddr)
+{
+    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
+}
+
+
+status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handleiRKNS_4RectEP13android_ycbcr(buffer_handle_t handle,
+        int usage, const Rect& bounds, android_ycbcr *ycbcr)
+{
+    return _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(handle, static_cast<uint32_t>(usage), bounds, ycbcr);
+}
+}
+#endif
+
 status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
         const Rect& bounds, void** vaddr)
 {
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 0000000..bb47e41
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,60 @@
+#define LOG_TAG "Fence"
+
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGD("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                int ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                int ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                String8 msg = String8::format(
+                    "sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%d.%06d)",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *(uint32_t *)pt_info->driver_data, ts_sec, ts_usec);
+                ALOGD("%s", msg.string());
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
+
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 0000000..a80857a
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,115 @@
+#define LOG_TAG "DumpTunnel"
+
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    // need to use different path for 32/64 env
+#ifdef __LP64__
+    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
+#else
+    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
+#endif
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
+
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 0000000..cfe29a1
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,112 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+#define RBD_LOGV(x, ...)
+#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+#define RBD_LOGW(x, ...)
+#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/process_name.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+
+RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
+    : mMonitor(pMonitor) {
+}
+
+RefBaseDump::~RefBaseDump() {
+}
+
+status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
+    return mMonitor->dump(result);
+}
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+    mDump = new RefBaseDump(this);
+    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
+}
+
+RefBaseMonitor::~RefBaseMonitor() {
+    RBD_LOGI("RefBaseMonitor dtor - %p", this);
+    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
+}
+
+status_t RefBaseMonitor::monitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    RbList.add(pRb, 0);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    RbList.removeItem(pRb);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::dump(String8& result) {
+    int listSz;
+    RefBase *pRb;
+    Mutex::Autolock _l(mMutex);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = RbList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (int i = 0; i < listSz; i++) {
+        pRb = RbList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+}
+
diff --git a/libs/ui/mediatek/test/Android.mk b/libs/ui/mediatek/test/Android.mk
new file mode 100644
index 0000000..82e7389
--- /dev/null
+++ b/libs/ui/mediatek/test/Android.mk
@@ -0,0 +1 @@
+#barrier
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
new file mode 100644
index 0000000..c984406
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
@@ -0,0 +1,16 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    RefBaseDumpTunnel.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libui
+
+LOCAL_MODULE:= test-RefBaseDumpTunnel
+
+LOCAL_MODULE_TAGS := tests
+
+include $(BUILD_EXECUTABLE)
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
new file mode 100644
index 0000000..c248230
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
@@ -0,0 +1,106 @@
+#include <stdio.h>
+#include <time.h>
+#include <utils/StrongPointer.h>
+#include "RefBaseDumpTunnel.h"
+
+using namespace android;
+
+void RefBaseMonitorTest_Assignment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    sp<RefBaseTest> sp2;
+    //printf("[1]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+         sp2 = sp1;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+}
+
+void RefBaseMonitorTest_CtorDtor(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    RefBaseTest *rbtmp;
+    //printf("[2]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        rbtmp = new RefBaseTest();
+        delete rbtmp;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorTest_CtorDtorAssgnment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    //printf("[3]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        sp1 = new RefBaseTest();
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorSubTest (int testRound, int testCntPerRound, void (*testFunc)(int, struct timespec *, struct timespec *)) {
+    struct timespec tsS;
+    struct timespec tsE;
+    int tmp;
+    int totalCnt;
+    int timeWithTracking = 0;
+
+    for(int j = 0; j < testRound; j++) {
+        //printf("Rnd: %d",j);
+        (*testFunc)(testCntPerRound, &tsS, &tsE);
+
+        tmp = tsE.tv_nsec - tsS.tv_nsec;
+        if (tmp < 0) {
+            tmp = 1000000000L + tsE.tv_nsec - tsS.tv_nsec;
+        }
+        timeWithTracking += tmp;
+        //printf("with RefBaseTracking....D:%d(ns)\n",tmp);
+    }
+    totalCnt = testRound * testCntPerRound;
+    printf("%12d(ns) = TotalTime: %12d(ns) / TestCnt: %d \n", timeWithTracking / totalCnt, timeWithTracking, totalCnt);
+
+}
+
+void RefBaseMonitorTest(int recCount, int testRound, int testCntPerRound) {
+    int tmp = recCount;
+    if (recCount == 0) {
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_Assignment);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtor);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtorAssgnment);
+    } else {
+        recCount--;
+        RefBaseMonitorTest(recCount, testRound, testCntPerRound);
+    }
+    printf("(stack:%d)", tmp);
+}
+
+int main(int argc, char** argv) {
+    int recLv;
+    int testRound;
+    int testCntPerRound;
+    int recCntTime;
+
+    if (argc == 5) {
+        sscanf(argv[1], "%d", &recLv);
+        sscanf(argv[2], "%d", &recCntTime);
+        sscanf(argv[3], "%d", &testRound);
+        sscanf(argv[4], "%d", &testCntPerRound);
+        if ((recLv >= 0) && (recCntTime > 0) && (testRound > 0) && (testCntPerRound > 0)) {
+            for (int i = 0; i < recCntTime; i++) {
+                printf("\nrec[ n + %d ]\n", i + recLv);
+                RefBaseMonitorTest(i + recLv, testRound, testCntPerRound);
+            }
+            printf("\n\n");
+            return 0;
+        }
+    }
+    printf("test-RefBaseDumpTunnel recLv recTimes testRnd testCntPerRnd\n");
+    return 0;
+}
+
+
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
new file mode 100644
index 0000000..84f21b0
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
@@ -0,0 +1,18 @@
+#include <utils/RefBase.h>
+#include <ui/mediatek/RefBaseDumpTunnel.h>
+
+namespace android
+{
+
+class RefBaseTest: public RefBase{
+    public:
+        RefBaseTest(){
+            RefBaseMonitor::getInstance().monitor(this);
+        }
+        ~RefBaseTest(){
+            RefBaseMonitor::getInstance().unmonitor(this);
+        }
+};
+
+};
+
-- 
2.7.4.1.g5468f9e

From 0c225449dc154c48cb02b4d4abc6ed250424ed11 Mon Sep 17 00:00:00 2001
From: GreenArrow9 <catbat.pc@gmail.com>
Date: Tue, 3 Jan 2017 14:45:02 +0000
Subject: [PATCH] Revert "libui:Add MTK Bits"

This reverts commit 9645f6f203a0bf6eaef5340ace435fe4a8cf7d14.
---
 include/ui/Fence.h                                 |   5 -
 include/ui/GraphicBufferMapper.h                   |   9 --
 include/ui/mediatek/IDumpTunnel.h                  |  50 ---------
 include/ui/mediatek/RefBaseDump.h                  |  64 ------------
 libs/ui/Android.mk                                 |  15 ---
 libs/ui/GraphicBufferMapper.cpp                    |  22 ----
 libs/ui/mediatek/Fence.cpp                         |  60 -----------
 libs/ui/mediatek/IDumpTunnel.cpp                   | 115 ---------------------
 libs/ui/mediatek/RefBaseDump.cpp                   | 112 --------------------
 libs/ui/mediatek/test/Android.mk                   |   1 -
 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk |  16 ---
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp   | 106 -------------------
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.h     |  18 ----
 13 files changed, 593 deletions(-)
 delete mode 100644 include/ui/mediatek/IDumpTunnel.h
 delete mode 100644 include/ui/mediatek/RefBaseDump.h
 delete mode 100644 libs/ui/mediatek/Fence.cpp
 delete mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 delete mode 100644 libs/ui/mediatek/RefBaseDump.cpp
 delete mode 100644 libs/ui/mediatek/test/Android.mk
 delete mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
 delete mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
 delete mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h

diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index befd640..b431bd5 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -110,11 +110,6 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
-
-#ifdef MTK_HARDWARE
-private:
-    void dump(int fd);
-#endif
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 37b819c..a25809c 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -66,15 +66,6 @@ private:
     std::unique_ptr<Gralloc1::Device> mDevice;
 };
 
-#ifdef MTK_HARDWARE
-extern "C" {
-
-    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
-            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
-
-}
-#endif
-
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
deleted file mode 100644
index 4ab32da..0000000
--- a/include/ui/mediatek/IDumpTunnel.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef ANDROID_GUI_IDUMPTUNNEL_H
-#define ANDROID_GUI_IDUMPTUNNEL_H
-
-#include <binder/IInterface.h>
-#include <utils/Singleton.h>
-
-namespace android
-{
-
-class IDumpTunnel : public IInterface {
-protected:
-    enum {
-        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
-    };
-
-public:
-    DECLARE_META_INTERFACE(DumpTunnel);
-
-    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
-};
-
-class BnDumpTunnel : public BnInterface<IDumpTunnel>
-{
-    virtual status_t onTransact(uint32_t code,
-                                const Parcel& data,
-                                Parcel* reply,
-                                uint32_t flags = 0);
-};
-
-// helper class for libgui_ext dynamic linking
-class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
-    void* mSoHandle;
-    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
-    bool (*mUnregDumpPtr)(const String8&);
-
-public:
-    DumpTunnelHelper();
-    virtual ~DumpTunnelHelper();
-
-    // register tunnel into guiext-server with a given key name
-    // and need to unregister it back
-    // in general usage, need to use identical key name for reg/unreg pair
-    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
-    bool unregDump(const String8& key);
-};
-
-
-};
-#endif
-
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
deleted file mode 100644
index a6a483d..0000000
--- a/include/ui/mediatek/RefBaseDump.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef ANDROID_REFBASE_DUMP_H__
-#define ANDROID_REFBASE_DUMP_H__
-
-#include <utils/String8.h>
-#include <utils/KeyedVector.h>
-#include <utils/Singleton.h>
-#include <ui/mediatek/IDumpTunnel.h>
-
-namespace android
-{
-class RefBaseMonitor;
-
-//-------------------------------------------------------------------------
-// RefBaseDump
-//-------------------------------------------------------------------------
-class RefBaseDump : public BnDumpTunnel {
-
-public:
-    RefBaseDump(RefBaseMonitor*);
-    virtual ~RefBaseDump();
-
-    // IDumpTunnel interface
-    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
-
-private:
-    RefBaseMonitor *mMonitor;
-};
-
-//-------------------------------------------------------------------------
-// RefBaseMonitor
-//-------------------------------------------------------------------------
-class RefBaseMonitor : public Singleton<RefBaseMonitor> {
-public:
-    RefBaseMonitor();
-    virtual ~RefBaseMonitor();
-
-    // add refbase to the monitored list
-    status_t monitor(RefBase* );
-
-    // remove refbase from the monitored list
-    status_t unmonitor(RefBase* );
-
-    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
-    status_t dump(String8& result);
-
-private:
-    status_t getProcessName();
-
-    // if trackMe needed
-    bool mIsTracking;
-
-    String8 mProcessName;
-
-    sp<RefBaseDump> mDump;
-
-    // the list where monitored refbase objects are saved
-    KeyedVector<RefBase*,int> RbList;
-
-    mutable Mutex mMutex;;
-};
-
-};
-#endif
-
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 97bfc14..e690ede 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -48,16 +48,6 @@ LOCAL_SRC_FILES := \
 	Region.cpp \
 	UiConfig.cpp
 
-ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
-LOCAL_SRC_FILES += \
-	mediatek/Fence.cpp \
-	mediatek/IDumpTunnel.cpp \
-	mediatek/RefBaseDump.cpp
-
-# just make everything compile for now... cleanups later
-LOCAL_CPPFLAGS := -std=c++1y -Weverything
-endif
-
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
 	libcutils \
@@ -66,11 +56,6 @@ LOCAL_SHARED_LIBRARIES := \
 	libutils \
 	liblog
 
-ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
-LOCAL_SHARED_LIBRARIES += \
-	libbinder
-endif
-
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index d30d1ec..481d43c 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -91,28 +91,6 @@ static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
     return outRect;
 }
 
-#ifdef MTK_HARDWARE
-extern "C" {
-
-extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
-extern status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(buffer_handle_t, uint32_t, const Rect&, android_ycbcr *);
-
-
-status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
-        int usage, const Rect& bounds, void** vaddr)
-{
-    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
-}
-
-
-status_t _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handleiRKNS_4RectEP13android_ycbcr(buffer_handle_t handle,
-        int usage, const Rect& bounds, android_ycbcr *ycbcr)
-{
-    return _ZN7android19GraphicBufferMapper9lockYCbCrEPK13native_handlejRKNS_4RectEP13android_ycbcr(handle, static_cast<uint32_t>(usage), bounds, ycbcr);
-}
-}
-#endif
-
 status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
         const Rect& bounds, void** vaddr)
 {
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
deleted file mode 100644
index bb47e41..0000000
--- a/libs/ui/mediatek/Fence.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-#define LOG_TAG "Fence"
-
-#include <sync/sync.h>
-#include <ui/Fence.h>
-#include <unistd.h>
-
-#include <cutils/log.h>
-
-// ---------------------------------------------------------------------------
-
-const char* findKeyWord(const char* msg) {
-    android::String8 obj_name(msg);
-    obj_name.toLower();
-    const char* OBJ_NAME = obj_name.string();
-
-    // NOTE: keep these keywords in sync with MOF
-    android::String8 keyword("timeline_");
-    if (strstr(OBJ_NAME, "surfaceflinger")) {
-        keyword.append("SurfaceFlinger");
-    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
-        keyword.append("ovl_timeline");
-    } else if (strstr(OBJ_NAME, "mali")) {
-        keyword.append("mali");
-    }
-
-    return keyword.string();
-}
-
-// ---------------------------------------------------------------------------
-
-namespace android {
-
-void Fence::dump(int fd) {
-    if (-1 == fd) return;
-
-    struct sync_fence_info_data *info = sync_fence_info(fd);
-    if (info) {
-        struct sync_pt_info *pt_info = NULL;
-        // status: active(0) signaled(1) error(<0)
-        ALOGD("fence(%s) status(%d)", info->name, info->status);
-
-        // iterate active/error sync points
-        while ((pt_info = sync_pt_info(info, pt_info))) {
-            if (NULL != pt_info && pt_info->status <= 0) {
-                int ts_sec = pt_info->timestamp_ns / 1000000000LL;
-                int ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
-
-                String8 msg = String8::format(
-                    "sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%d.%06d)",
-                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
-                    *(uint32_t *)pt_info->driver_data, ts_sec, ts_usec);
-                ALOGD("%s", msg.string());
-            }
-        }
-        sync_fence_info_free(info);
-    }
-}
-
-} // namespace android
-
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
deleted file mode 100644
index a80857a..0000000
--- a/libs/ui/mediatek/IDumpTunnel.cpp
+++ /dev/null
@@ -1,115 +0,0 @@
-#define LOG_TAG "DumpTunnel"
-
-#include <dlfcn.h>
-#include <utils/String8.h>
-#include <binder/Parcel.h>
-#include <cutils/log.h>
-#include <ui/mediatek/IDumpTunnel.h>
-
-namespace android {
-
-// client : proxy GuiEx class
-class BpDumpTunnel : public BpInterface<IDumpTunnel> {
-public:
-    BpDumpTunnel(const sp<IBinder>& impl)
-        :   BpInterface<IDumpTunnel>(impl) {
-    }
-
-    virtual status_t kickDump(String8& result, const char* prefix) {
-        Parcel data, reply;
-        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
-        data.writeString8(result);
-        data.writeCString(prefix);
-        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
-        if (err != NO_ERROR) {
-            ALOGE("kickDump could not contact remote\n");
-            return err;
-        }
-        result = reply.readString8();
-        err = reply.readInt32();
-        return err;
-    }
-};
-
-IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
-
-status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
-    switch (code) {
-        case DUMPTUNNEL_DUMP: {
-            CHECK_INTERFACE(IDumpTunnel, data, reply);
-            String8 result;
-            const char* prefix = NULL;
-            result = data.readString8();
-            prefix = data.readCString();
-
-            status_t ret = kickDump(result, prefix);
-            reply->writeString8(result);
-            reply->writeInt32(ret);
-            return NO_ERROR;
-        } break;
-    }
-    return BBinder::onTransact(code, data, reply, flags);
-}
-
-// ----------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
-
-DumpTunnelHelper::DumpTunnelHelper() :
-    mSoHandle(NULL),
-    mRegDumpPtr(NULL),
-    mUnregDumpPtr(NULL)
-{
-    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
-    typedef bool (*UnregDumpPrototype)(const String8&);
-
-    // dlopen must set RTLD_LAZY flag because of performance issue
-    // need to use different path for 32/64 env
-#ifdef __LP64__
-    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
-#else
-    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
-#endif
-    if (mSoHandle) {
-        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
-        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
-        if (NULL == mRegDumpPtr) {
-            ALOGE("finding regDump() failed");
-        }
-        if (NULL == mUnregDumpPtr) {
-            ALOGE("finding unregDump() failed");
-        }
-    } else {
-        ALOGE("open libgui_ext failed");
-    }
-}
-
-DumpTunnelHelper::~DumpTunnelHelper() {
-    if(mSoHandle != NULL)
-        dlclose(mSoHandle);
-}
-
-bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
-    bool result = false;
-    if (NULL == mRegDumpPtr) {
-        ALOGE("finding regDump() failed");
-        return result;
-    }
-    result = mRegDumpPtr(tunnel, key);
-
-    return result;
-}
-
-bool DumpTunnelHelper::unregDump(const String8& key) {
-    bool result = false;
-    if (NULL == mUnregDumpPtr) {
-        ALOGE("finding unregDump() failed");
-        return result;
-    }
-    result = mUnregDumpPtr(key);
-
-    return result;
-}
-
-};
-
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
deleted file mode 100644
index cfe29a1..0000000
--- a/libs/ui/mediatek/RefBaseDump.cpp
+++ /dev/null
@@ -1,112 +0,0 @@
-#define LOG_TAG "RefBaseDump"
-
-#if 0
-#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
-#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
-#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
-#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
-#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
-#else
-#define RBD_LOGV(x, ...)
-#define RBD_LOGD(x, ...)
-#define RBD_LOGI(x, ...)
-#define RBD_LOGW(x, ...)
-#define RBD_LOGE(x, ...)
-#endif
-
-#include <cutils/log.h>
-#include <cutils/process_name.h>
-#include <cutils/properties.h>
-#include <ui/mediatek/RefBaseDump.h>
-
-namespace android {
-
-//-------------------------------------------------------------------------
-// RefBaseDump
-//-------------------------------------------------------------------------
-
-RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
-    : mMonitor(pMonitor) {
-}
-
-RefBaseDump::~RefBaseDump() {
-}
-
-status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
-    return mMonitor->dump(result);
-}
-
-//-------------------------------------------------------------------------
-// RefBaseMonitor
-//-------------------------------------------------------------------------
-
-ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
-
-RefBaseMonitor::RefBaseMonitor() {
-    char value[PROPERTY_VALUE_MAX];
-    RBD_LOGI("RefBaseMonitor ctor - %p", this);
-    getProcessName();
-    property_get("debug.rb.dump", value, "Mary had a little lamb");
-    mIsTracking = (-1 != mProcessName.find(value));
-    mDump = new RefBaseDump(this);
-    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
-}
-
-RefBaseMonitor::~RefBaseMonitor() {
-    RBD_LOGI("RefBaseMonitor dtor - %p", this);
-    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
-}
-
-status_t RefBaseMonitor::monitor(RefBase *pRb) {
-    Mutex::Autolock _l(mMutex);
-    if (mIsTracking) {
-        pRb->trackMe(true, false);
-    }
-    RbList.add(pRb, 0);
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
-    Mutex::Autolock _l(mMutex);
-    RbList.removeItem(pRb);
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::dump(String8& result) {
-    int listSz;
-    RefBase *pRb;
-    Mutex::Autolock _l(mMutex);
-    RBD_LOGI("RefBaseMonitor Dump - %p", this);
-    listSz = RbList.size();
-    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
-    result.append(mIsTracking ? " <- tracking\n" : "\n");
-    result.append("\t  -----------------------\n");
-
-    for (int i = 0; i < listSz; i++) {
-        pRb = RbList.keyAt(i);
-        if (mIsTracking) {
-            pRb->printRefs();
-        }
-        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
-    }
-    result.append("\t*****************************************************\n");
-    return NO_ERROR;
-}
-
-status_t RefBaseMonitor::getProcessName() {
-    int pid = getpid();
-    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
-    if (NULL != fp) {
-        const size_t size = 64;
-        char proc_name[size];
-        fgets(proc_name, size, fp);
-        fclose(fp);
-        mProcessName = proc_name;
-    } else {
-        mProcessName = "unknownProcess";
-    }
-    return NO_ERROR;
-}
-
-}
-
diff --git a/libs/ui/mediatek/test/Android.mk b/libs/ui/mediatek/test/Android.mk
deleted file mode 100644
index 82e7389..0000000
--- a/libs/ui/mediatek/test/Android.mk
+++ /dev/null
@@ -1 +0,0 @@
-#barrier
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
deleted file mode 100644
index c984406..0000000
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
+++ /dev/null
@@ -1,16 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    RefBaseDumpTunnel.cpp
-
-LOCAL_SHARED_LIBRARIES := \
-    libutils \
-    libui
-
-LOCAL_MODULE:= test-RefBaseDumpTunnel
-
-LOCAL_MODULE_TAGS := tests
-
-include $(BUILD_EXECUTABLE)
-
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
deleted file mode 100644
index c248230..0000000
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
+++ /dev/null
@@ -1,106 +0,0 @@
-#include <stdio.h>
-#include <time.h>
-#include <utils/StrongPointer.h>
-#include "RefBaseDumpTunnel.h"
-
-using namespace android;
-
-void RefBaseMonitorTest_Assignment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
-    sp<RefBaseTest> sp1 = new RefBaseTest();
-    sp<RefBaseTest> sp2;
-    //printf("[1]");
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
-    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
-    for (int i = 0; i < testCnt; i++) {
-         sp2 = sp1;
-    }
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
-}
-
-void RefBaseMonitorTest_CtorDtor(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
-    RefBaseTest *rbtmp;
-    //printf("[2]");
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
-    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
-    for (int i = 0; i < testCnt; i++) {
-        rbtmp = new RefBaseTest();
-        delete rbtmp;
-    }
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
-    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
-}
-
-void RefBaseMonitorTest_CtorDtorAssgnment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
-    sp<RefBaseTest> sp1 = new RefBaseTest();
-    //printf("[3]");
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
-    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
-    for (int i = 0; i < testCnt; i++) {
-        sp1 = new RefBaseTest();
-    }
-    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
-    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
-}
-
-void RefBaseMonitorSubTest (int testRound, int testCntPerRound, void (*testFunc)(int, struct timespec *, struct timespec *)) {
-    struct timespec tsS;
-    struct timespec tsE;
-    int tmp;
-    int totalCnt;
-    int timeWithTracking = 0;
-
-    for(int j = 0; j < testRound; j++) {
-        //printf("Rnd: %d",j);
-        (*testFunc)(testCntPerRound, &tsS, &tsE);
-
-        tmp = tsE.tv_nsec - tsS.tv_nsec;
-        if (tmp < 0) {
-            tmp = 1000000000L + tsE.tv_nsec - tsS.tv_nsec;
-        }
-        timeWithTracking += tmp;
-        //printf("with RefBaseTracking....D:%d(ns)\n",tmp);
-    }
-    totalCnt = testRound * testCntPerRound;
-    printf("%12d(ns) = TotalTime: %12d(ns) / TestCnt: %d \n", timeWithTracking / totalCnt, timeWithTracking, totalCnt);
-
-}
-
-void RefBaseMonitorTest(int recCount, int testRound, int testCntPerRound) {
-    int tmp = recCount;
-    if (recCount == 0) {
-        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_Assignment);
-        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtor);
-        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtorAssgnment);
-    } else {
-        recCount--;
-        RefBaseMonitorTest(recCount, testRound, testCntPerRound);
-    }
-    printf("(stack:%d)", tmp);
-}
-
-int main(int argc, char** argv) {
-    int recLv;
-    int testRound;
-    int testCntPerRound;
-    int recCntTime;
-
-    if (argc == 5) {
-        sscanf(argv[1], "%d", &recLv);
-        sscanf(argv[2], "%d", &recCntTime);
-        sscanf(argv[3], "%d", &testRound);
-        sscanf(argv[4], "%d", &testCntPerRound);
-        if ((recLv >= 0) && (recCntTime > 0) && (testRound > 0) && (testCntPerRound > 0)) {
-            for (int i = 0; i < recCntTime; i++) {
-                printf("\nrec[ n + %d ]\n", i + recLv);
-                RefBaseMonitorTest(i + recLv, testRound, testCntPerRound);
-            }
-            printf("\n\n");
-            return 0;
-        }
-    }
-    printf("test-RefBaseDumpTunnel recLv recTimes testRnd testCntPerRnd\n");
-    return 0;
-}
-
-
-
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
deleted file mode 100644
index 84f21b0..0000000
--- a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#include <utils/RefBase.h>
-#include <ui/mediatek/RefBaseDumpTunnel.h>
-
-namespace android
-{
-
-class RefBaseTest: public RefBase{
-    public:
-        RefBaseTest(){
-            RefBaseMonitor::getInstance().monitor(this);
-        }
-        ~RefBaseTest(){
-            RefBaseMonitor::getInstance().unmonitor(this);
-        }
-};
-
-};
-
-- 
2.7.4.1.g5468f9e

From a662e305663da589e0df71e3d1d0d2ed75766189 Mon Sep 17 00:00:00 2001
From: GreenArrow9 <catbat.pc@gmail.com>
Date: Tue, 3 Jan 2017 15:12:06 +0000
Subject: [PATCH] MTK bits

---
 include/ui/Fence.h                                 |   6 ++
 include/ui/GraphicBufferMapper.h                   |   8 ++
 include/ui/mediatek/IDumpTunnel.h                  |  51 +++++++++
 include/ui/mediatek/RefBaseDump.h                  |  65 ++++++++++++
 libs/ui/Android.mk                                 |  14 +++
 libs/ui/GraphicBufferMapper.cpp                    |  13 +++
 libs/ui/mediatek/Fence.cpp                         |  61 +++++++++++
 libs/ui/mediatek/IDumpTunnel.cpp                   | 116 +++++++++++++++++++++
 libs/ui/mediatek/RefBaseDump.cpp                   | 113 ++++++++++++++++++++
 libs/ui/mediatek/test/Android.mk                   |   1 +
 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk |  17 +++
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp   | 107 +++++++++++++++++++
 .../test/RefBaseDumpTunnel/RefBaseDumpTunnel.h     |  19 ++++
 13 files changed, 591 insertions(+)
 create mode 100644 include/ui/mediatek/IDumpTunnel.h
 create mode 100644 include/ui/mediatek/RefBaseDump.h
 create mode 100644 libs/ui/mediatek/Fence.cpp
 create mode 100644 libs/ui/mediatek/IDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/RefBaseDump.cpp
 create mode 100644 libs/ui/mediatek/test/Android.mk
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
 create mode 100644 libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h

diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index b431bd5..bc4575d 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -110,6 +110,12 @@ private:
     const Fence& operator = (const Fence& rhs) const;
 
     int mFenceFd;
+
+#ifdef MTK_HARDWARE
+private:
+    void dump(int fd);
+#endif
+
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index a25809c..ef25f68 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -66,6 +66,14 @@ private:
     std::unique_ptr<Gralloc1::Device> mDevice;
 };
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+    status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(
+            buffer_handle_t handle, int usage, const Rect& bounds, void** vaddr);
+
+}
+#endif
 // ---------------------------------------------------------------------------
 
 }; // namespace android
diff --git a/include/ui/mediatek/IDumpTunnel.h b/include/ui/mediatek/IDumpTunnel.h
new file mode 100644
index 0000000..1d8f3c0
--- /dev/null
+++ b/include/ui/mediatek/IDumpTunnel.h
@@ -0,0 +1,51 @@
+#ifndef ANDROID_GUI_IDUMPTUNNEL_H
+#define ANDROID_GUI_IDUMPTUNNEL_H
+
+#include <binder/IInterface.h>
+#include <utils/Singleton.h>
+
+namespace android
+{
+
+class IDumpTunnel : public IInterface {
+protected:
+    enum {
+        DUMPTUNNEL_DUMP = IBinder::FIRST_CALL_TRANSACTION
+    };
+
+public:
+    DECLARE_META_INTERFACE(DumpTunnel);
+
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/) = 0;
+};
+
+class BnDumpTunnel : public BnInterface<IDumpTunnel>
+{
+    virtual status_t onTransact(uint32_t code,
+                                const Parcel& data,
+                                Parcel* reply,
+                                uint32_t flags = 0);
+};
+
+// helper class for libgui_ext dynamic linking
+class DumpTunnelHelper : public Singleton<DumpTunnelHelper> {
+    void* mSoHandle;
+    bool (*mRegDumpPtr)(const sp<IDumpTunnel>&, const String8&);
+    bool (*mUnregDumpPtr)(const String8&);
+
+public:
+    DumpTunnelHelper();
+    virtual ~DumpTunnelHelper();
+
+    // register tunnel into guiext-server with a given key name
+    // and need to unregister it back
+    // in general usage, need to use identical key name for reg/unreg pair
+    bool regDump(const sp<IDumpTunnel>& tunnel, const String8& key);
+    bool unregDump(const String8& key);
+};
+
+
+};
+#endif
+
+
diff --git a/include/ui/mediatek/RefBaseDump.h b/include/ui/mediatek/RefBaseDump.h
new file mode 100644
index 0000000..45a376f
--- /dev/null
+++ b/include/ui/mediatek/RefBaseDump.h
@@ -0,0 +1,65 @@
+#ifndef ANDROID_REFBASE_DUMP_H__
+#define ANDROID_REFBASE_DUMP_H__
+
+#include <utils/String8.h>
+#include <utils/KeyedVector.h>
+#include <utils/Singleton.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android
+{
+class RefBaseMonitor;
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+class RefBaseDump : public BnDumpTunnel {
+
+public:
+    RefBaseDump(RefBaseMonitor*);
+    virtual ~RefBaseDump();
+
+    // IDumpTunnel interface
+    virtual status_t kickDump(String8& /*result*/, const char* /*prefix*/);
+
+private:
+    RefBaseMonitor *mMonitor;
+};
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+class RefBaseMonitor : public Singleton<RefBaseMonitor> {
+public:
+    RefBaseMonitor();
+    virtual ~RefBaseMonitor();
+
+    // add refbase to the monitored list
+    status_t monitor(RefBase* );
+
+    // remove refbase from the monitored list
+    status_t unmonitor(RefBase* );
+
+    // dump all elements in the monitored list and call printRefs if mIsTracking equals 1
+    status_t dump(String8& result);
+
+private:
+    status_t getProcessName();
+
+    // if trackMe needed
+    bool mIsTracking;
+
+    String8 mProcessName;
+
+    sp<RefBaseDump> mDump;
+
+    // the list where monitored refbase objects are saved
+    KeyedVector<RefBase*,int> RbList;
+
+    mutable Mutex mMutex;;
+};
+
+};
+#endif
+
+
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index e690ede..4b42b7c 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -48,6 +48,16 @@ LOCAL_SRC_FILES := \
 	Region.cpp \
 	UiConfig.cpp
 
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SRC_FILES += \
+	mediatek/Fence.cpp \
+	mediatek/IDumpTunnel.cpp \
+	mediatek/RefBaseDump.cpp
+
+# just make everything compile for now... cleanups later
+LOCAL_CPPFLAGS := -std=c++1y -Weverything
+
+endif
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
 	libcutils \
@@ -55,6 +65,10 @@ LOCAL_SHARED_LIBRARIES := \
 	libsync \
 	libutils \
 	liblog
+ifeq ($(BOARD_HAS_MTK_HARDWARE),true)
+LOCAL_SHARED_LIBRARIES += \
+	libbinder
+endif
 
 ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 481d43c..61ff4a7 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -91,6 +91,19 @@ static inline gralloc1_rect_t asGralloc1Rect(const Rect& rect) {
     return outRect;
 }
 
+#ifdef MTK_HARDWARE
+extern "C" {
+
+extern status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(buffer_handle_t, uint32_t, const Rect&, void**);
+
+status_t _ZN7android19GraphicBufferMapper4lockEPK13native_handleiRKNS_4RectEPPv(buffer_handle_t handle,
+        int usage, const Rect& bounds, void** vaddr)
+{
+    return _ZN7android19GraphicBufferMapper4lockEPK13native_handlejRKNS_4RectEPPv(handle, static_cast<uint32_t>(usage), bounds, vaddr);
+}
+
+}
+#endif
 status_t GraphicBufferMapper::lock(buffer_handle_t handle, uint32_t usage,
         const Rect& bounds, void** vaddr)
 {
diff --git a/libs/ui/mediatek/Fence.cpp b/libs/ui/mediatek/Fence.cpp
new file mode 100644
index 0000000..c0905bc
--- /dev/null
+++ b/libs/ui/mediatek/Fence.cpp
@@ -0,0 +1,61 @@
+#define LOG_TAG "Fence"
+
+#include <sync/sync.h>
+#include <ui/Fence.h>
+#include <unistd.h>
+
+#include <cutils/log.h>
+
+// ---------------------------------------------------------------------------
+
+const char* findKeyWord(const char* msg) {
+    android::String8 obj_name(msg);
+    obj_name.toLower();
+    const char* OBJ_NAME = obj_name.string();
+
+    // NOTE: keep these keywords in sync with MOF
+    android::String8 keyword("timeline_");
+    if (strstr(OBJ_NAME, "surfaceflinger")) {
+        keyword.append("SurfaceFlinger");
+    } else if (strstr(OBJ_NAME, "ovl_timeline")) {
+        keyword.append("ovl_timeline");
+    } else if (strstr(OBJ_NAME, "mali")) {
+        keyword.append("mali");
+    }
+
+    return keyword.string();
+}
+
+// ---------------------------------------------------------------------------
+
+namespace android {
+
+void Fence::dump(int fd) {
+    if (-1 == fd) return;
+
+    struct sync_fence_info_data *info = sync_fence_info(fd);
+    if (info) {
+        struct sync_pt_info *pt_info = NULL;
+        // status: active(0) signaled(1) error(<0)
+        ALOGD("fence(%s) status(%d)", info->name, info->status);
+
+        // iterate active/error sync points
+        while ((pt_info = sync_pt_info(info, pt_info))) {
+            if (NULL != pt_info && pt_info->status <= 0) {
+                int ts_sec = pt_info->timestamp_ns / 1000000000LL;
+                int ts_usec = (pt_info->timestamp_ns % 1000000000LL) / 1000LL;
+
+                String8 msg = String8::format(
+                    "sync point: timeline(%s) drv(%s) status(%d) sync_drv(%u) timestamp(%d.%06d)",
+                    pt_info->obj_name, pt_info->driver_name, pt_info->status,
+                    *(uint32_t *)pt_info->driver_data, ts_sec, ts_usec);
+                ALOGD("%s", msg.string());
+            }
+        }
+        sync_fence_info_free(info);
+    }
+}
+
+} // namespace android
+
+
diff --git a/libs/ui/mediatek/IDumpTunnel.cpp b/libs/ui/mediatek/IDumpTunnel.cpp
new file mode 100644
index 0000000..4457202
--- /dev/null
+++ b/libs/ui/mediatek/IDumpTunnel.cpp
@@ -0,0 +1,116 @@
+#define LOG_TAG "DumpTunnel"
+
+#include <dlfcn.h>
+#include <utils/String8.h>
+#include <binder/Parcel.h>
+#include <cutils/log.h>
+#include <ui/mediatek/IDumpTunnel.h>
+
+namespace android {
+
+// client : proxy GuiEx class
+class BpDumpTunnel : public BpInterface<IDumpTunnel> {
+public:
+    BpDumpTunnel(const sp<IBinder>& impl)
+        :   BpInterface<IDumpTunnel>(impl) {
+    }
+
+    virtual status_t kickDump(String8& result, const char* prefix) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IDumpTunnel::getInterfaceDescriptor());
+        data.writeString8(result);
+        data.writeCString(prefix);
+        status_t err = remote()->transact(DUMPTUNNEL_DUMP, data, &reply);
+        if (err != NO_ERROR) {
+            ALOGE("kickDump could not contact remote\n");
+            return err;
+        }
+        result = reply.readString8();
+        err = reply.readInt32();
+        return err;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(DumpTunnel, "DumpTunnel");
+
+status_t BnDumpTunnel::onTransact(uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) {
+    switch (code) {
+        case DUMPTUNNEL_DUMP: {
+            CHECK_INTERFACE(IDumpTunnel, data, reply);
+            String8 result;
+            const char* prefix = NULL;
+            result = data.readString8();
+            prefix = data.readCString();
+
+            status_t ret = kickDump(result, prefix);
+            reply->writeString8(result);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+    }
+    return BBinder::onTransact(code, data, reply, flags);
+}
+
+// ----------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(DumpTunnelHelper);
+
+DumpTunnelHelper::DumpTunnelHelper() :
+    mSoHandle(NULL),
+    mRegDumpPtr(NULL),
+    mUnregDumpPtr(NULL)
+{
+    typedef bool (*RegDumpPrototype)(const sp<IDumpTunnel>&, const String8&);
+    typedef bool (*UnregDumpPrototype)(const String8&);
+
+    // dlopen must set RTLD_LAZY flag because of performance issue
+    // need to use different path for 32/64 env
+#ifdef __LP64__
+    mSoHandle = dlopen("/system/lib64/libgui_ext.so", RTLD_LAZY);
+#else
+    mSoHandle = dlopen("/system/lib/libgui_ext.so", RTLD_LAZY);
+#endif
+    if (mSoHandle) {
+        mRegDumpPtr = reinterpret_cast<RegDumpPrototype>(dlsym(mSoHandle, "regDump"));
+        mUnregDumpPtr = reinterpret_cast<UnregDumpPrototype>(dlsym(mSoHandle, "unregDump"));
+        if (NULL == mRegDumpPtr) {
+            ALOGE("finding regDump() failed");
+        }
+        if (NULL == mUnregDumpPtr) {
+            ALOGE("finding unregDump() failed");
+        }
+    } else {
+        ALOGE("open libgui_ext failed");
+    }
+}
+
+DumpTunnelHelper::~DumpTunnelHelper() {
+    if(mSoHandle != NULL)
+        dlclose(mSoHandle);
+}
+
+bool DumpTunnelHelper::regDump(const sp<IDumpTunnel>& tunnel, const String8& key) {
+    bool result = false;
+    if (NULL == mRegDumpPtr) {
+        ALOGE("finding regDump() failed");
+        return result;
+    }
+    result = mRegDumpPtr(tunnel, key);
+
+    return result;
+}
+
+bool DumpTunnelHelper::unregDump(const String8& key) {
+    bool result = false;
+    if (NULL == mUnregDumpPtr) {
+        ALOGE("finding unregDump() failed");
+        return result;
+    }
+    result = mUnregDumpPtr(key);
+
+    return result;
+}
+
+};
+
+
diff --git a/libs/ui/mediatek/RefBaseDump.cpp b/libs/ui/mediatek/RefBaseDump.cpp
new file mode 100644
index 0000000..0db0d97
--- /dev/null
+++ b/libs/ui/mediatek/RefBaseDump.cpp
@@ -0,0 +1,113 @@
+#define LOG_TAG "RefBaseDump"
+
+#if 0
+#define RBD_LOGV(x, ...) ALOGV(x, ##__VA_ARGS__)
+#define RBD_LOGD(x, ...) ALOGD(x, ##__VA_ARGS__)
+#define RBD_LOGI(x, ...) ALOGI(x, ##__VA_ARGS__)
+#define RBD_LOGW(x, ...) ALOGW(x, ##__VA_ARGS__)
+#define RBD_LOGE(x, ...) ALOGE(x, ##__VA_ARGS__)
+#else
+#define RBD_LOGV(x, ...)
+#define RBD_LOGD(x, ...)
+#define RBD_LOGI(x, ...)
+#define RBD_LOGW(x, ...)
+#define RBD_LOGE(x, ...)
+#endif
+
+#include <cutils/log.h>
+#include <cutils/process_name.h>
+#include <cutils/properties.h>
+#include <ui/mediatek/RefBaseDump.h>
+
+namespace android {
+
+//-------------------------------------------------------------------------
+// RefBaseDump
+//-------------------------------------------------------------------------
+
+RefBaseDump::RefBaseDump(RefBaseMonitor* pMonitor)
+    : mMonitor(pMonitor) {
+}
+
+RefBaseDump::~RefBaseDump() {
+}
+
+status_t RefBaseDump::kickDump(String8& result, const char* prefix) {
+    return mMonitor->dump(result);
+}
+
+//-------------------------------------------------------------------------
+// RefBaseMonitor
+//-------------------------------------------------------------------------
+
+ANDROID_SINGLETON_STATIC_INSTANCE(RefBaseMonitor)
+
+RefBaseMonitor::RefBaseMonitor() {
+    char value[PROPERTY_VALUE_MAX];
+    RBD_LOGI("RefBaseMonitor ctor - %p", this);
+    getProcessName();
+    property_get("debug.rb.dump", value, "Mary had a little lamb");
+    mIsTracking = (-1 != mProcessName.find(value));
+    mDump = new RefBaseDump(this);
+    DumpTunnelHelper::getInstance().regDump(mDump, String8::format("RB-%p", this));
+}
+
+RefBaseMonitor::~RefBaseMonitor() {
+    RBD_LOGI("RefBaseMonitor dtor - %p", this);
+    DumpTunnelHelper::getInstance().unregDump(String8::format("RB-%p", this));
+}
+
+status_t RefBaseMonitor::monitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    if (mIsTracking) {
+        pRb->trackMe(true, false);
+    }
+    RbList.add(pRb, 0);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::unmonitor(RefBase *pRb) {
+    Mutex::Autolock _l(mMutex);
+    RbList.removeItem(pRb);
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::dump(String8& result) {
+    int listSz;
+    RefBase *pRb;
+    Mutex::Autolock _l(mMutex);
+    RBD_LOGI("RefBaseMonitor Dump - %p", this);
+    listSz = RbList.size();
+    result.appendFormat("\t  [%8p]    RefCnt   %s", this, mProcessName.string());
+    result.append(mIsTracking ? " <- tracking\n" : "\n");
+    result.append("\t  -----------------------\n");
+
+    for (int i = 0; i < listSz; i++) {
+        pRb = RbList.keyAt(i);
+        if (mIsTracking) {
+            pRb->printRefs();
+        }
+        result.appendFormat("\t   %2d) %8p %4d\n", i, pRb, pRb->getStrongCount());
+    }
+    result.append("\t*****************************************************\n");
+    return NO_ERROR;
+}
+
+status_t RefBaseMonitor::getProcessName() {
+    int pid = getpid();
+    FILE *fp = fopen(String8::format("/proc/%d/cmdline", pid), "r");
+    if (NULL != fp) {
+        const size_t size = 64;
+        char proc_name[size];
+        fgets(proc_name, size, fp);
+        fclose(fp);
+        mProcessName = proc_name;
+    } else {
+        mProcessName = "unknownProcess";
+    }
+    return NO_ERROR;
+}
+
+}
+
+
diff --git a/libs/ui/mediatek/test/Android.mk b/libs/ui/mediatek/test/Android.mk
new file mode 100644
index 0000000..82e7389
--- /dev/null
+++ b/libs/ui/mediatek/test/Android.mk
@@ -0,0 +1 @@
+#barrier
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
new file mode 100644
index 0000000..f6983a2
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/Android.mk
@@ -0,0 +1,17 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    RefBaseDumpTunnel.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libutils \
+    libui
+
+LOCAL_MODULE:= test-RefBaseDumpTunnel
+
+LOCAL_MODULE_TAGS := tests
+
+include $(BUILD_EXECUTABLE)
+
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
new file mode 100644
index 0000000..e4ed8b1
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.cpp
@@ -0,0 +1,107 @@
+#include <stdio.h>
+#include <time.h>
+#include <utils/StrongPointer.h>
+#include "RefBaseDumpTunnel.h"
+
+using namespace android;
+
+void RefBaseMonitorTest_Assignment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    sp<RefBaseTest> sp2;
+    //printf("[1]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+         sp2 = sp1;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+}
+
+void RefBaseMonitorTest_CtorDtor(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    RefBaseTest *rbtmp;
+    //printf("[2]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        rbtmp = new RefBaseTest();
+        delete rbtmp;
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorTest_CtorDtorAssgnment(int testCnt, struct timespec *tsS, struct timespec *tsE ) {
+    sp<RefBaseTest> sp1 = new RefBaseTest();
+    //printf("[3]");
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsS);
+    //printf("with RefBaseTracking....S:%d(ns)\n",tsS.tv_nsec);
+    for (int i = 0; i < testCnt; i++) {
+        sp1 = new RefBaseTest();
+    }
+    clock_gettime(CLOCK_PROCESS_CPUTIME_ID, tsE);
+    //printf("with RefBaseTracking....E:%d(ns)\n",tsE.tv_nsec);
+}
+
+void RefBaseMonitorSubTest (int testRound, int testCntPerRound, void (*testFunc)(int, struct timespec *, struct timespec *)) {
+    struct timespec tsS;
+    struct timespec tsE;
+    int tmp;
+    int totalCnt;
+    int timeWithTracking = 0;
+
+    for(int j = 0; j < testRound; j++) {
+        //printf("Rnd: %d",j);
+        (*testFunc)(testCntPerRound, &tsS, &tsE);
+
+        tmp = tsE.tv_nsec - tsS.tv_nsec;
+        if (tmp < 0) {
+            tmp = 1000000000L + tsE.tv_nsec - tsS.tv_nsec;
+        }
+        timeWithTracking += tmp;
+        //printf("with RefBaseTracking....D:%d(ns)\n",tmp);
+    }
+    totalCnt = testRound * testCntPerRound;
+    printf("%12d(ns) = TotalTime: %12d(ns) / TestCnt: %d \n", timeWithTracking / totalCnt, timeWithTracking, totalCnt);
+
+}
+
+void RefBaseMonitorTest(int recCount, int testRound, int testCntPerRound) {
+    int tmp = recCount;
+    if (recCount == 0) {
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_Assignment);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtor);
+        RefBaseMonitorSubTest(testRound, testCntPerRound, RefBaseMonitorTest_CtorDtorAssgnment);
+    } else {
+        recCount--;
+        RefBaseMonitorTest(recCount, testRound, testCntPerRound);
+    }
+    printf("(stack:%d)", tmp);
+}
+
+int main(int argc, char** argv) {
+    int recLv;
+    int testRound;
+    int testCntPerRound;
+    int recCntTime;
+
+    if (argc == 5) {
+        sscanf(argv[1], "%d", &recLv);
+        sscanf(argv[2], "%d", &recCntTime);
+        sscanf(argv[3], "%d", &testRound);
+        sscanf(argv[4], "%d", &testCntPerRound);
+        if ((recLv >= 0) && (recCntTime > 0) && (testRound > 0) && (testCntPerRound > 0)) {
+            for (int i = 0; i < recCntTime; i++) {
+                printf("\nrec[ n + %d ]\n", i + recLv);
+                RefBaseMonitorTest(i + recLv, testRound, testCntPerRound);
+            }
+            printf("\n\n");
+            return 0;
+        }
+    }
+    printf("test-RefBaseDumpTunnel recLv recTimes testRnd testCntPerRnd\n");
+    return 0;
+}
+
+
+
+
diff --git a/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
new file mode 100644
index 0000000..bb50e2a
--- /dev/null
+++ b/libs/ui/mediatek/test/RefBaseDumpTunnel/RefBaseDumpTunnel.h
@@ -0,0 +1,19 @@
+#include <utils/RefBase.h>
+#include <ui/mediatek/RefBaseDumpTunnel.h>
+
+namespace android
+{
+
+class RefBaseTest: public RefBase{
+    public:
+        RefBaseTest(){
+            RefBaseMonitor::getInstance().monitor(this);
+        }
+        ~RefBaseTest(){
+            RefBaseMonitor::getInstance().unmonitor(this);
+        }
+};
+
+};
+
+
-- 
2.7.4.1.g5468f9e


